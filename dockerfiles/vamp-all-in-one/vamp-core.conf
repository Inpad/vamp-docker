akka {

  loglevel = "INFO"
  log-dead-letters = on
  log-config-on-start = off
  loggers = ["akka.event.slf4j.Slf4jLogger"]
  event-handlers = ["akka.event.slf4j.Slf4jEventHandler"]

  actor {
    debug {
      fsm = on
      receive = on
      lifecycle = on
      autoreceive = on
      event-stream = on
    }

    default-mailbox {
      mailbox-type = "akka.dispatch.SingleConsumerOnlyUnboundedMailbox"
    }
  }

  default-dispatcher.fork-join-executor.pool-size-max = 32
  jvm-exit-on-fatal-error = false
}

server {

  interface = 0.0.0.0
  host = localhost
  port = 8080

  response {
    timeout = 180 # seconds, HTTP response timeout
  }
}

persistence {
  response = {
    timeout = 4000
  }

  database-schema-name = ""
  //  # for example for postgres
  //  slick-driver = "scala.slick.driver.PostgresDriver$"
  //  jdbcProvider = {
  //    url = "jdbc:postgresql://<hostname>/<database-name>"
  //    user = "<db-user>"
  //    password = "<db-password>"
  //    connectionPool = disabled
  //    keepAliveConnection = true
  //  }

  # for H2 in memory
  slick-driver = "scala.slick.driver.H2Driver$"
  jdbcProvider = {
    url = "jdbc:h2:mem:vamp"
    driver = org.h2.Driver
    connectionPool = disabled
    keepAliveConnection = true
  }
}

deployment {

  sla.period = 5 # seconds, sla monitor period
  escalation.period = 5 # seconds, escalation monitor period
  synchronization.period = 5 # seconds, watchdog will be active only if period is greater than 0

  deployment-synchronization-mailbox {
    // Until we get available akka.dispatch.NonBlockingBoundedMailbox
    mailbox-type = "akka.dispatch.BoundedMailbox"
    mailbox-capacity = 10
    mailbox-push-timeout-time = 0s
  }

  timeout {
    ready-for-deployment: 600 # seconds
    ready-for-undeployment: 600 # seconds
  }

  container {
    driver {
      type = "marathon"
      url = "http://localhost:8080"
      url = ${?VAMP_MARATHON_URL}
    }
    response.timeout = 180 # seconds, timeout for container operations

    default-scale {
      instances: 1
      cpu: 0.5
      memory: 512
    }
  }

  router {
    driver.url = "http://localhost:10001"
    host = "localhost" # note: host of cluster hosts will have this value (e.g. db.host)
    response.timeout = 180 # seconds, timeout for container operations
  }

  pulse {
    driver.url = "http://localhost:8083"
    response.timeout = 180 # seconds, timeout for pulse operations
  }

  dictionary {
    response.timeout = 180 # seconds, timeout for container operations
    port.range = 33000-35000
  }
}

spray.can {

  server {
    server-header = ""
    ssl-encryption = off
    pipelining-limit = 1
    idle-timeout = 60 s
    request-timeout = 20 s
    verbose-error-messages = off
    automatic-back-pressure-handling = on
    back-pressure {
      noack-rate = 10
      reading-low-watermark = infinite
    }
    ssl-tracing = off
  }
}